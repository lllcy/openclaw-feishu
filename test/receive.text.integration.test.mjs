import test from 'node:test';
import assert from 'node:assert/strict';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';

// NOTE: tests run against dist output (generated by npm run build).
import { setFeishuRuntime } from '../dist/src/runtime.js';
import { __internal as receiveInternal } from '../dist/src/receive.js';

function makeFakeClient() {
  const calls = [];
  const client = {
    im: {
      message: {
        create: async (req) => {
          calls.push({ kind: 'message.create', req });
          return { data: { message_id: 'm_created' } };
        },
        reply: async (req) => {
          calls.push({ kind: 'message.reply', req });
          return { data: { message_id: 'm_reply' } };
        },
        update: async (req) => {
          calls.push({ kind: 'message.update', req });
          return { data: { message_id: req?.path?.message_id || 'm_update' } };
        },
        delete: async (req) => {
          calls.push({ kind: 'message.delete', req });
          return { ok: true };
        },
      },
      image: {
        create: async (req) => {
          calls.push({ kind: 'image.create', req });
          return { data: { image_key: 'img_key_test' } };
        },
      },
      file: {
        create: async (req) => {
          calls.push({ kind: 'file.create', req });
          return { data: { file_key: 'file_key_test' } };
        },
      },
    },
  };
  return { client, calls };
}

function makeRuntimeThatReplies(payload) {
  return {
    channel: {
      reply: {
        dispatchReplyWithBufferedBlockDispatcher: async ({ dispatcherOptions }) => {
          await dispatcherOptions.deliver(payload);
        },
      },
    },
    config: {
      loadConfig: () => ({}),
    },
  };
}

function makeCtx({ client, thinkingThresholdMs = 0 } = {}) {
  return {
    client,
    account: {
      accountId: 'default',
      name: 'test',
      enabled: true,
      appId: 'cli_xxx',
      appSecret: 'secret',
      tokenSource: 'config',
      config: { thinkingThresholdMs },
    },
    config: {},
    log: {
      info: () => {},
      error: () => {},
    },
    thinkingThresholdMs,
    botNames: ['bot', '助手'],
  };
}

function makeTextEvent({ text, chatType = 'p2p', mentions = [], messageId = undefined } = {}) {
  return {
    message: {
      chat_id: chatType === 'p2p' ? 'oc_test_chat' : 'oc_test_group',
      message_id: messageId || `om_${Date.now()}_${Math.random().toString(16).slice(2)}`,
      chat_type: chatType,
      message_type: 'text',
      content: JSON.stringify({ text }),
      mentions,
    },
    sender: {
      sender_id: {
        open_id: 'ou_sender',
      },
    },
  };
}

function tinyPngPath() {
  const b64 =
    // 1x1 PNG
    'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMB/ax7u0cAAAAASUVORK5CYII=';
  const fp = path.join(os.tmpdir(), `feishu_openclaw_test_${Date.now()}.png`);
  fs.writeFileSync(fp, Buffer.from(b64, 'base64'));
  return fp;
}

// --- Integration: inbound text -> outbound text

test('receive: p2p text message triggers a text reply', async () => {
  const { client, calls } = makeFakeClient();
  setFeishuRuntime(makeRuntimeThatReplies('hello from bot'));

  const ctx = makeCtx({ client, thinkingThresholdMs: 0 });
  const evt = makeTextEvent({ text: 'hi' });

  await receiveInternal.handleIncomingMessage(evt, ctx);

  const sent = calls.filter((c) => c.kind === 'message.create');
  assert.equal(sent.length, 1);
  assert.equal(sent[0].req.data.msg_type, 'text');
  const parsed = JSON.parse(sent[0].req.data.content);
  assert.equal(parsed.text, 'hello from bot');
});

// --- Integration: group message not addressed -> no reply

test('receive: group message without mention should be filtered (no reply)', async () => {
  const { client, calls } = makeFakeClient();
  setFeishuRuntime(makeRuntimeThatReplies('should not send'));

  const ctx = makeCtx({ client, thinkingThresholdMs: 0 });
  const evt = makeTextEvent({ text: '随便聊聊', chatType: 'group', mentions: [] });

  await receiveInternal.handleIncomingMessage(evt, ctx);

  const sent = calls.filter((c) => c.kind === 'message.create');
  assert.equal(sent.length, 0);
});

// --- Integration: outbound mediaUrl -> sendMediaMessage path

test('receive: when agent returns mediaUrl, it sends an image message (local file path)', async () => {
  const { client, calls } = makeFakeClient();

  const imgPath = tinyPngPath();
  setFeishuRuntime(makeRuntimeThatReplies({ mediaUrl: imgPath, text: 'caption' }));

  const ctx = makeCtx({ client, thinkingThresholdMs: 0 });
  const evt = makeTextEvent({ text: 'generate image' });

  await receiveInternal.handleIncomingMessage(evt, ctx);

  const imageUploads = calls.filter((c) => c.kind === 'image.create');
  assert.equal(imageUploads.length, 1);

  const creates = calls.filter((c) => c.kind === 'message.create');
  // 1) image message 2) text message
  assert.ok(creates.length >= 1);
  assert.equal(creates[0].req.data.msg_type, 'image');

  // cleanup (delay a bit because createReadStream opens async)
  await new Promise((r) => setTimeout(r, 30));
  try { fs.unlinkSync(imgPath); } catch {}
});
